<xs:schema attributeFormDefault="unqualified" elementFormDefault="unqualified" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:vc="http://www.w3.org/2007/XMLSchema-versioning" vc:minVersion="1.1">
  <xs:element name="scene">
    <xs:complexType>
      <xs:all>
        <xs:element name="variables">
          <xs:annotation>
            <xs:documentation>
              Variables are the core of the scene producer realtime animation possibilities.
              In this section the user defined variables are specified.
              Public variables are accessible as CG parameters and by the parent scene when nested inside another.
              There are some variables that are always defined like
              "frame" which stores the number of frames that have gone by since the scene producer started,
              "mouse_x" and "mouse_y" which reflect the X and Y position of the mouse at all times relative to the scene coordinate system (requires interaction aware consumer like screen_consumer),
              "timeline_frame" which differs from "frame" in that it can rewind and jump, depending on where the timeline is at the moment,
              "fps" which always contains the framerate of the scene and
              "scene_width" and "scene_height" which contains the dimensions of the scene coordinate system.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="variable" maxOccurs="unbounded" minOccurs="0">
                <xs:annotation>
                  <xs:documentation>
                    A scene variable can be referenced in expressions.
                    It is defined under variable.[id] unless it is public because then it is in the global namespace [id].
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:simpleContent>
                    <xs:annotation>
                      <xs:documentation>
                        Could be a constant or an expression.
                        An expression is written as ${expr}.
                        Must be parseable/resolved as the type specified.
                      </xs:documentation>
                    </xs:annotation>
                    <xs:extension base="any_expression">
                      <xs:attribute type="identifier" name="id" use="required"><xs:annotation><xs:documentation>The unique variable name. Will be exposed as [id] if the variable is public or variable.[id] otherwise.</xs:documentation></xs:annotation></xs:attribute>
                      <xs:attribute type="type" name="type" use="required"><xs:annotation><xs:documentation>The variable type. The value/expression of the variable must be parseable/resolvable as/to this type.</xs:documentation></xs:annotation></xs:attribute>
                      <xs:attribute type="boolean" name="public" default="false"><xs:annotation><xs:documentation>Whether the variable should be accessible from outside the scene or not. Public variables can be accessed via CG UPDATE, CG ADD and as layer.[layerid].parameter.[id] when nested inside another scene.</xs:documentation></xs:annotation></xs:attribute>
                    </xs:extension>
                  </xs:simpleContent>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
          <xs:unique name="uniqueVariableNames">
            <xs:selector xpath="variable" />
            <xs:field xpath="@id" />
          </xs:unique>
        </xs:element>
        <xs:element name="layers">
          <xs:annotation>
            <xs:documentation>
              The layers of the scene.
              The layers defined first will be above the ones defined after.
              All properties of each layer are addressable from expressions as layer.[id].[property].
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="layer" minOccurs="0" maxOccurs="unbounded">
                <xs:complexType>
                  <xs:all>
                    <xs:element type="producer_string" name="producer">                                                     <xs:annotation><xs:documentation>The same syntax as in AMCP after for example PLAY 1-10. Cannot be an expression.</xs:documentation></xs:annotation></xs:element>
                    <xs:element type="bool_expression" name="hidden" minOccurs="0" default="false">                         <xs:annotation><xs:documentation>Hides the layer if true. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                    <xs:element type="number_expression" name="x">                                                          <xs:annotation><xs:documentation>The X coordinate of the layer in the scene coordinate system. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                    <xs:element type="number_expression" name="y">                                                          <xs:annotation><xs:documentation>The Y coordinate of the layer in the scene coordinate system. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                    <xs:element type="number_expression" name="width" minOccurs="0">                                        <xs:annotation><xs:documentation>The width of the layer. Is by default calculated by the producer itself but can be overridden. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                    <xs:element type="number_expression" name="height" minOccurs="0">                                       <xs:annotation><xs:documentation>The height of the layer. Is by default calculated by the producer itself but can be overridden. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                    <xs:element name="clip" minOccurs="0">
                      <xs:annotation>
                        <xs:documentation>
                          Properties regarding viewport clipping. The coordinates are relative to the scene coordinate system. They are addressable from expressions as layer.[id].clip.[property].
                        </xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:all>
                          <xs:element type="number_expression" name="upper_left_x" minOccurs="0" default="0">                <xs:annotation><xs:documentation>The X position within the scene coordinate system to clip the upper left corner. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="upper_left_y" minOccurs="0" default="0">                <xs:annotation><xs:documentation>The Y position within the scene coordinate system to clip the upper left corner. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="lower_right_x" minOccurs="0">                           <xs:annotation><xs:documentation>The X position within the scene coordinate system to clip the lower right corner. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="lower_right_y" minOccurs="0">                           <xs:annotation><xs:documentation>The Y position within the scene coordinate system to clip the lower right corner. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                        </xs:all>
                      </xs:complexType>
                    </xs:element>
                    <xs:element type="number_expression" name="anchor_x" minOccurs="0" default="0">                         <xs:annotation><xs:documentation>The X anchor within the layer coordinate system where position and rotation are done relative to/around. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                    <xs:element type="number_expression" name="anchor_y" minOccurs="0" default="0">                         <xs:annotation><xs:documentation>The Y anchor within the layer coordinate system where position and rotation are done relative to/around. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                    <xs:element type="number_expression" name="rotation" minOccurs="0" default="0.0">                       <xs:annotation><xs:documentation>The rotation of the layer around anchor_x/anchor_y expressed in degrees. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                    <xs:element name="crop" minOccurs="0">
                      <xs:annotation>
                        <xs:documentation>
                          Properties for cropping the layer. The coordinates are relative to the layer coordinate system. They are addressable from expressions as layer.[id].crop.[property].
                        </xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:all>
                          <xs:element type="number_expression" name="upper_left_x" minOccurs="0" default="0">               <xs:annotation><xs:documentation>The X position within the layer coordinate system to crop the upper left corner. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="upper_left_y" minOccurs="0" default="0">               <xs:annotation><xs:documentation>The Y position within the layer coordinate system to crop the upper left corner. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="lower_right_x" minOccurs="0">                          <xs:annotation><xs:documentation>The X position within the layer coordinate system to crop the lower right corner. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="lower_right_y" minOccurs="0">                          <xs:annotation><xs:documentation>The Y position within the layer coordinate system to crop the lower right corner. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                        </xs:all>
                      </xs:complexType>
                    </xs:element>
                    <xs:element name="perspective" minOccurs="0">
                      <xs:annotation>
                        <xs:documentation>
                          Properties for perspective/corner pin of the layer. The coordinates are relative to the layer coordinate system. They are addressable from expressions as layer.[id].perspective.[property].
                        </xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:all>
                          <xs:element type="number_expression" name="upper_left_x" minOccurs="0" default="0">               <xs:annotation><xs:documentation>The X position within the layer coordinate system to corner pin the upper left corner. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="upper_left_y" minOccurs="0" default="0">               <xs:annotation><xs:documentation>The Y position within the layer coordinate system to corner pin the upper left corner. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="upper_right_x" minOccurs="0">                          <xs:annotation><xs:documentation>The X position within the layer coordinate system to corner pin the upper right corner. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="upper_right_y" minOccurs="0" default="0">              <xs:annotation><xs:documentation>The Y position within the layer coordinate system to corner pin the upper right corner. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="lower_right_x" minOccurs="0">                          <xs:annotation><xs:documentation>The X position within the layer coordinate system to corner pin the lower right corner. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="lower_right_y" minOccurs="0">                          <xs:annotation><xs:documentation>The Y position within the layer coordinate system to corner pin the lower right corner. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="lower_left_x" minOccurs="0" default="0">               <xs:annotation><xs:documentation>The X position within the layer coordinate system to corner pin the lower left corner. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="lower_left_y" minOccurs="0">                           <xs:annotation><xs:documentation>The Y position within the layer coordinate system to corner pin the lower left corner. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                        </xs:all>
                      </xs:complexType>
                    </xs:element>
                    <xs:element name="adjustments" minOccurs="0">
                      <xs:annotation>
                        <xs:documentation>
                          Properties regarding image adjustments. They are addressable from expressions as layer.[id].adjustment.[property].
                        </xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:all>
                          <xs:element type="number_expression" name="opacity" minOccurs="0" default="1.0">                  <xs:annotation><xs:documentation>The opacity of the layer. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="contrast" minOccurs="0" default="1.0">                 <xs:annotation><xs:documentation>The contrast of the layer. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="saturation" minOccurs="0" default="1.0">               <xs:annotation><xs:documentation>The saturation of the layer. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="brightness" minOccurs="0" default="1.0">               <xs:annotation><xs:documentation>The brightness of the layer. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                        </xs:all>
                      </xs:complexType>
                    </xs:element>
                    <xs:element name="levels" minOccurs="0">
                      <xs:annotation>
                        <xs:documentation>
                          Properties regarding level adjustments. They are addressable from expressions as layer.[id].level.[property].
                        </xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:all>
                          <xs:element type="number_expression" name="min_input" minOccurs="0" default="0.0">                <xs:annotation><xs:documentation>The minimum input level of the layer. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="max_input" minOccurs="0" default="1.0">                <xs:annotation><xs:documentation>The maximum input level of the layer. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="gamma" minOccurs="0" default="1.0">                    <xs:annotation><xs:documentation>The gamma correction of the layer. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="min_output" minOccurs="0" default="0.0">               <xs:annotation><xs:documentation>The minimum output level of the layer. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="max_output" minOccurs="0" default="1.0">               <xs:annotation><xs:documentation>The maximum output level of the layer. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                        </xs:all>
                      </xs:complexType>
                    </xs:element>
                    <xs:element type="bool_expression" name="is_key" minOccurs="0" default="false">                         <xs:annotation><xs:documentation>If true causes the layer to key the layer above. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                    <xs:element type="bool_expression" name="use_mipmap" minOccurs="0" default="false">                     <xs:annotation><xs:documentation>Whether to enable mipmapping on the layer or not. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                    <xs:element type="blend_mode" name="blend_mode" minOccurs="0" default="normal">                         <xs:annotation><xs:documentation>The blend mode to use. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                    <xs:element name="chroma_key" minOccurs="0">
                      <xs:complexType>
                        <xs:all>
                          <xs:element type="bool_expression" name="enable" minOccurs="0" default="false">                   <xs:annotation><xs:documentation>Whether to enable chroma keying on the layer or not. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="target_hue" minOccurs="0" default="120.0">             <xs:annotation><xs:documentation>The degrees within 0-360 of the hue window centrum of the color to key. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="hue_width" minOccurs="0" default="0.1">                <xs:annotation><xs:documentation>How wide within 0.0-1.0 the hue window of the color to key should be. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="min_saturation" minOccurs="0" default="0.0">           <xs:annotation><xs:documentation>The minimum saturation within 0.0-1.0 of the color to key. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="min_brightness" minOccurs="0" default="0.0">           <xs:annotation><xs:documentation>The minimum brightness within 0.0-1.0 of the color to key. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="softness" minOccurs="0" default="0.0">                 <xs:annotation><xs:documentation>How soft the chroma key window should be within 0.0-1.0. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="spill_suppress" minOccurs="0" default="0.0">           <xs:annotation><xs:documentation>How much to suppress spill by within 0.0-180.0. It works by taking all hue values within +- this value from target_hue and clamps it to either target_hue - this value or target_hue + this value depending on which side it is closest to. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                          <xs:element type="number_expression" name="spill_suppress_saturation" minOccurs="0" default="1.0"><xs:annotation><xs:documentation>Controls how much saturation should be kept on colors affected by spill_suppress within 0.0-1.0. Full saturation may not always be desirable to be kept on suppressed colors. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                        </xs:all>
                      </xs:complexType>
                    </xs:element>
                    <xs:element type="number_expression" name="volume" minOccurs="0" default="1.0">                         <xs:annotation><xs:documentation>The audio volume of the layer. Can be an expression.</xs:documentation></xs:annotation></xs:element>
                    <xs:element name="parameters" minOccurs="0">
                      <xs:annotation>
                        <xs:documentation>
                          A producer can expose variables that can be referenced from the scene.
                          The element names used here should reflect the name of the parameter that should be set.
                          Even if a parameter is not defined here they can still be accessed by other expressions under layer.[id].parameter.[variable].
                          If a scene producer is nested inside a scene producer its variables marked public will be available.
                          If a text producer exposes "text", "tracking", "current_bearing_y" and "current_protrude_under_y"
                        </xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:sequence>
                          <xs:any minOccurs="0" maxOccurs="unbounded" processContents="skip" />
                        </xs:sequence>
                      </xs:complexType>
                    </xs:element>
                  </xs:all>
                  <xs:attribute type="identifier" name="id" use="required" />
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
          <xs:unique name="uniqueLayerNames">
            <xs:selector xpath="layer" />
            <xs:field xpath="@id" />
          </xs:unique>
        </xs:element>
        <xs:element name="marks" minOccurs="0">
          <xs:annotation>
            <xs:documentation>
              Marks are placed on specific timeline frames and marks start of animation sequences, stop of animation sequence and removal of the entire scene.
              They affect what happens when CG PLAY, CG STOP, CG INVOKE and CG NEXT are sent via AMCP.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="mark" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                  <xs:documentation>
                    One of the mark types is "start" which marks the start of a named animation. There is an implicit start mark at frame 0 called "intro" which is started when CG PLAY is executed. The "intro" animation can be defined at another frame if desired. There is another start mark that should be called "outro" which is coupled to CG STOP. Any other start mark is used with CG INVOKE.
                    Another mark type is "stop" which makes the timeline stop when reached. The only thing that can make the timeline move again is a CG NEXT, CG STOP or a CG INVOKE.
                    The "jump_to" mark type tells the timeline to jump to another "start" whenever reached, enabling the possibility of creating animation loops.
                    The last mark type is "remove" with the only purpose of completely stopping rendering when reached. It is used instead of "stop" to mark the end of the "outro" animation.
                    Note that a "stop" or "jump_to" can be on the same frame as a "start" for example on end of intro and start of outro. There will be no conflict in this case when outro is started.
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:attribute type="xs:nonNegativeInteger" name="at" use="required"><xs:annotation><xs:documentation>The timeline frame to place the mark at.</xs:documentation></xs:annotation></xs:attribute>
                  <xs:attribute type="mark_action" name="type" use="required">
                    <xs:annotation>
                      <xs:documentation>
                        The type of mark.
                        "start" marks the start of an animation sequence.
                        "stop" means that any animation should stop at the marked frame.
                        "jump_to" means that the entire timeline should jump to the mentioned start label whenever the frame is encountered.
                        "remove" is usually the end of the "outro" animation and causes the scene to stop rendering completely.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute type="identifier" name="label" use="optional"><xs:annotation><xs:documentation>Is only used for "start" and "jump_to" marks and defines the name of the animation for "start" and the destination start for "jump_to".</xs:documentation></xs:annotation></xs:attribute>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="timelines" minOccurs="0">
          <xs:annotation>
            <xs:documentation>
              Each variable/layer property may be manipulated by a timeline to animate the value based on keyframes.
              The timelines are collectively moved forward in time based on the marks section and the CG command interaction from the outside.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="timeline" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                  <xs:documentation>
                    A timeline manipulates only one variable/layer property.
                    The position on the timeline at any given time is globally controlled via the marks of the scene, so all timelines are always at the same frame as each other.
                    If the variable/layer property is already bound to an expression it will be overridden by the timeline.
                    Currently only number variables/layer properties are supported on timelines.
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="keyframe" minOccurs="0" maxOccurs="unbounded">
                      <xs:annotation>
                        <xs:documentation>
                          Each keyframe specifies a value that the variable should have at a specific timeline frame.
                          The value can be either immediately changed if no easing is specified, otherwise it is animated to the value with the given easing curve.
                          The actual value to animate to can itself be an expression.
                        </xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:simpleContent>
                          <xs:extension base="number_expression">
                            <xs:attribute name="at" type="xs:nonNegativeInteger" use="required"><xs:annotation><xs:documentation>The frame to place the keyframe at.</xs:documentation></xs:annotation></xs:attribute>
                            <xs:attribute name="easing" type="easing" use="optional"><xs:annotation><xs:documentation>If omitted there will be no animation but an immediate value change instead.</xs:documentation></xs:annotation></xs:attribute>
                          </xs:extension>
                        </xs:simpleContent>
                      </xs:complexType>
                    </xs:element>
                  </xs:sequence>
                  <xs:attribute name="variable" type="variable_reference" use="required"><xs:annotation><xs:documentation>The variable/layer property to manipulate. If it already has an expression the expression will be overridden.</xs:documentation></xs:annotation></xs:attribute>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
          <xs:unique name="oneTimelinePerVariable">
            <xs:selector xpath="timeline" />
            <xs:field xpath="@variable" />
          </xs:unique>
        </xs:element>
        <xs:element name="tasks" minOccurs="0">
          <xs:annotation>
            <xs:documentation>
              Tasks are scheduled to happen whenever a certain condition arises.
              Use the at attribute to let the condition be that the timeline arrives at a specific frame
              or the when attribute to specify a custom bool expression that when becomes true triggers the task.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element name="call">
                <xs:annotation><xs:documentation>Performs the equivalent of an AMCP CALL on the specified layer.</xs:documentation></xs:annotation>
                <xs:complexType>
                  <xs:sequence maxOccurs="unbounded">
                    <xs:element name="arg" type="xs:string"><xs:annotation><xs:documentation>See the producer documentation for the possible arguments.</xs:documentation></xs:annotation></xs:element>
                  </xs:sequence>
                  <xs:attribute name="at" use="optional" type="xs:nonNegativeInteger"><xs:annotation><xs:documentation>Trigger the CALL when the timeline gets to this specific frame.</xs:documentation></xs:annotation></xs:attribute>
                  <xs:attribute name="when" use="optional" type="bool_expression"><xs:annotation><xs:documentation>Trigger the CALL when the specified bool expression becomes true.</xs:documentation></xs:annotation></xs:attribute>
                  <xs:attribute name="to_layer" use="required" type="identifier"><xs:annotation><xs:documentation>The producer on this layer will receive the CALL.</xs:documentation></xs:annotation></xs:attribute>
                </xs:complexType>
              </xs:element>
              <xs:element name="cg_play">
                <xs:annotation><xs:documentation>Performs the equivalent of a CG PLAY on the specified layer.</xs:documentation></xs:annotation>
                <xs:complexType>
                  <xs:attribute name="at" use="optional" type="xs:nonNegativeInteger"><xs:annotation><xs:documentation>Trigger the CG PLAY when the timeline gets to this specific frame.</xs:documentation></xs:annotation></xs:attribute>
                  <xs:attribute name="when" use="optional" type="bool_expression"><xs:annotation><xs:documentation>Trigger the CG PLAY when the specified bool expression becomes true.</xs:documentation></xs:annotation></xs:attribute>
                  <xs:attribute name="to_layer" use="required" type="identifier"><xs:annotation><xs:documentation>The CG producer on this layer will receive the CG PLAY.</xs:documentation></xs:annotation></xs:attribute>
                </xs:complexType>
              </xs:element>
              <xs:element name="cg_stop">
                <xs:annotation><xs:documentation>Performs the equivalent of a CG STOP on the specified layer.</xs:documentation></xs:annotation>
                <xs:complexType>
                  <xs:attribute name="at" use="optional" type="xs:nonNegativeInteger"><xs:annotation><xs:documentation>Trigger the CG STOP when the timeline gets to this specific frame.</xs:documentation></xs:annotation></xs:attribute>
                  <xs:attribute name="when" use="optional" type="bool_expression"><xs:annotation><xs:documentation>Trigger the CG STOP when the specified bool expression becomes true.</xs:documentation></xs:annotation></xs:attribute>
                  <xs:attribute name="to_layer" use="required" type="identifier"><xs:annotation><xs:documentation>The CG producer on this layer will receive the CG STOP.</xs:documentation></xs:annotation></xs:attribute>
                </xs:complexType>
              </xs:element>
              <xs:element name="cg_next">
                <xs:annotation><xs:documentation>Performs the equivalent of a CG NEXT on the specified layer.</xs:documentation></xs:annotation>
                <xs:complexType>
                  <xs:attribute name="at" use="optional" type="xs:nonNegativeInteger"><xs:annotation><xs:documentation>Trigger the CG NEXT when the timeline gets to this specific frame.</xs:documentation></xs:annotation></xs:attribute>
                  <xs:attribute name="when" use="optional" type="bool_expression"><xs:annotation><xs:documentation>Trigger the CG NEXT when the specified bool expression becomes true.</xs:documentation></xs:annotation></xs:attribute>
                  <xs:attribute name="to_layer" use="required" type="identifier"><xs:annotation><xs:documentation>The CG producer on this layer will receive the CG NEXT.</xs:documentation></xs:annotation></xs:attribute>
                </xs:complexType>
              </xs:element>
              <xs:element name="cg_invoke">
                <xs:annotation><xs:documentation>Performs the equivalent of a CG INVOKE on the specified layer with the specified label.</xs:documentation></xs:annotation>
                <xs:complexType>
                  <xs:attribute name="at" use="optional" type="xs:nonNegativeInteger"><xs:annotation><xs:documentation>Trigger the CG INVOKE when the timeline gets to this specific frame.</xs:documentation></xs:annotation></xs:attribute>
                  <xs:attribute name="when" use="optional" type="bool_expression"><xs:annotation><xs:documentation>Trigger the CG INVOKE when the specified bool expression becomes true.</xs:documentation></xs:annotation></xs:attribute>
                  <xs:attribute name="to_layer" use="required" type="identifier"><xs:annotation><xs:documentation>The CG producer on this layer will receive the CG INVOKE.</xs:documentation></xs:annotation></xs:attribute>
                  <xs:attribute name="label" use="required" type="nonEmptyString"><xs:annotation><xs:documentation>The label that will be invoked.</xs:documentation></xs:annotation></xs:attribute>
                </xs:complexType>
              </xs:element>
              <xs:element name="goto_mark">
                <xs:annotation><xs:documentation>Makes the scene go to a specific start mark given a specific condition becoming true.</xs:documentation></xs:annotation>
                <xs:complexType>
                  <xs:attribute name="when" use="required" type="bool_expression"><xs:annotation><xs:documentation>Go to the start mark when the specified bool expression becomes true.</xs:documentation></xs:annotation></xs:attribute>
                  <xs:attribute name="label" use="required" type="nonEmptyString"><xs:annotation><xs:documentation>The label of the start mark that the scene should go to.</xs:documentation></xs:annotation></xs:attribute>
                </xs:complexType>
              </xs:element>
            </xs:choice>
          </xs:complexType>
        </xs:element>
      </xs:all>
      <xs:attribute type="xs:positiveInteger" name="width" use="required" />
      <xs:attribute type="xs:positiveInteger" name="height" use="required" />
    </xs:complexType>
  </xs:element>
  <xs:simpleType name="type">
    <xs:restriction base="xs:string">
      <xs:whiteSpace value="collapse" />
      <xs:enumeration value="string" />
      <xs:enumeration value="number" />
      <xs:enumeration value="bool" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="identifier">
    <xs:restriction base="xs:string">
      <xs:whiteSpace value="collapse" />
      <xs:pattern value="[a-zA-Z_][a-zA-Z0-9_]*" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="variable_reference">
    <xs:restriction base="xs:string">
      <xs:whiteSpace value="collapse" />
      <xs:pattern value="[a-zA-Z_][a-z\.A-Z0-9_]*" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="nonEmptyString">
    <xs:restriction base="xs:string">
      <xs:whiteSpace value="collapse" />
      <xs:minLength value="1" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="boolean">
    <xs:restriction base="xs:string">
      <xs:whiteSpace value="collapse" />
      <xs:enumeration value="true" />
      <xs:enumeration value="false" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="expression">
    <xs:restriction base="xs:string">
      <xs:annotation>
        <xs:documentation>
        </xs:documentation>
      </xs:annotation>
      <xs:whiteSpace value="collapse" />
      <xs:pattern value="$\{.+\}" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="string_expression_examples">
    <xs:restriction base="xs:string">
      <xs:enumeration value="A string constant" />
      <xs:enumeration value="${&quot;A string constant&quot;}" />
      <xs:enumeration value="${variable.some_string + &quot; will be concatenated&quot;}" />
      <xs:enumeration value="${to_lower(variable.some_string)}" />
      <xs:enumeration value="${to_upper(variable.some_string)}" />
      <xs:enumeration value="${&quot;Concatenate string with number: &quot; + variable.some_number}" />
      <xs:enumeration value="${&quot;Concatenate string with different strings based on bool: &quot; + (variable.some_bool ? &quot;Enabled&quot; : &quot;Disabled&quot;)}" />
      <xs:enumeration value="${mouse_x &lt; 640 ? &quot;Left of middle&quot; : variable.message_when_right_of_middle}" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="string_expression">
    <xs:union memberTypes="xs:string expression string_expression_examples" />
  </xs:simpleType>

  <xs:simpleType name="available_blend_modes">
    <xs:restriction base="xs:string">
      <xs:enumeration value="normal" />
      <xs:enumeration value="lighten" />
      <xs:enumeration value="darken" />
      <xs:enumeration value="multiply" />
      <xs:enumeration value="average" />
      <xs:enumeration value="add" />
      <xs:enumeration value="subtract" />
      <xs:enumeration value="difference" />
      <xs:enumeration value="negation" />
      <xs:enumeration value="exclusion" />
      <xs:enumeration value="screen" />
      <xs:enumeration value="overlay" />
      <xs:enumeration value="soft_light" />
      <xs:enumeration value="hard_light" />
      <xs:enumeration value="color_dodge" />
      <xs:enumeration value="color_burn" />
      <xs:enumeration value="linear_dodge" />
      <xs:enumeration value="linear_burn" />
      <xs:enumeration value="linear_light" />
      <xs:enumeration value="vivid_light" />
      <xs:enumeration value="pin_light" />
      <xs:enumeration value="hard_mix" />
      <xs:enumeration value="reflect" />
      <xs:enumeration value="glow" />
      <xs:enumeration value="phoenix" />
      <xs:enumeration value="contrast" />
      <xs:enumeration value="saturation" />
      <xs:enumeration value="color" />
      <xs:enumeration value="luminosity" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="blend_mode_expression_examples">
    <xs:restriction base="xs:string">
      <xs:enumeration value="${should_lighten ? &quot;lighten&quot; : &quot;normal&quot;}" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="blend_mode">
    <xs:union memberTypes="available_blend_modes expression blend_mode_expression_examples" />
  </xs:simpleType>

  <xs:simpleType name="number_expression_examples">
    <xs:restriction base="xs:string">
      <xs:whiteSpace value="collapse" />
      <xs:enumeration value="0" />
      <xs:enumeration value="0.0" />
      <xs:enumeration value="${0.0}" />
      <xs:enumeration value="${variable.foo + variable.bar}" />
      <xs:enumeration value="${layer.foo.x + layer.foo.width + variable.bar_offset_x}" />
      <xs:enumeration value="${variable.foo + 640.0}" />
      <xs:enumeration value="${variable.foo - variable.bar}" />
      <xs:enumeration value="${1.0 - variable.bar}" />
      <xs:enumeration value="${variable.foo * variable.bar}" />
      <xs:enumeration value="${variable.foo / variable.bar}" />
      <xs:enumeration value="${variable.foo % variable.bar}" />
      <xs:enumeration value="${(variable.a + variable.b) * variable.c}" />
      <xs:enumeration value="${frame &lt; 50 ? variable.initial_value : variable.value_after_a_while}" />
      <xs:enumeration value="${sin(angle)}" />
      <xs:enumeration value="${cos(angle)}" />
      <xs:enumeration value="${abs(value)}" />
      <xs:enumeration value="${floor(value)}" />
      <xs:enumeration value="${length(str)}" />
      <xs:enumeration value="${animate(expression_to_animate, duration, tweener)}" />
      <xs:enumeration value="${animate(layer.to_follow.x, 200, &quot;easeoutelastic&quot;)}" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="number_expression">
    <xs:union memberTypes="xs:decimal expression number_expression_examples" />
  </xs:simpleType>

  <xs:simpleType name="bool_expression_examples">
    <xs:restriction base="xs:string">
      <xs:whiteSpace value="collapse" />
      <xs:enumeration value="${variable.some_number == 50}" />
      <xs:enumeration value="${variable.some_number != 50}" />
      <xs:enumeration value="${variable.some_string == &quot;true when strings are equal&quot;}" />
      <xs:enumeration value="${variable.some_string != &quot;false when strings are equal&quot;}" />
      <xs:enumeration value="${frame &gt; 50}" />
      <xs:enumeration value="${frame &lt; 50}" />
      <xs:enumeration value="${frame &gt;= 50}" />
      <xs:enumeration value="${frame &lt;= 50}" />
      <xs:enumeration value="${!variable.some_bool}" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="bool_expression">
    <xs:union memberTypes="boolean expression bool_expression_examples" />
  </xs:simpleType>

  <xs:simpleType name="any_expression">
    <xs:union memberTypes="string_expression number_expression bool_expression" />
  </xs:simpleType>

  <xs:simpleType name="producer_examples">
    <xs:restriction base="xs:string">
      <xs:whiteSpace value="collapse" />
      <xs:enumeration value="RED" />
      <xs:enumeration value="#AA0000AA" />
      <xs:enumeration value="amb LOOP" />
      <xs:enumeration value="rtmp://example.com/stream" />
      <xs:enumeration value="[HTML] http://casparcg.com" />
      <xs:enumeration value="[TEXT] &quot;&quot; 0 0 size 30 color #1b698d font ArialMT" />
      <xs:enumeration value="[TEXT] &quot;Initial text before bound via layer.text_layer.param.text&quot; 0 0 size 30 color #1b698d font ArialMT" />
      <xs:enumeration value="route://1" />
      <xs:enumeration value="route://1-10" />
      <xs:enumeration value="child_scene" />
      <xs:enumeration value="DECKLINK 8 FORMAT 1080i5000 FILTER DEINTERLACE_BOB" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="producer_string">
    <xs:union memberTypes="nonEmptyString producer_examples" />
  </xs:simpleType>

  <xs:simpleType name="mark_action">
    <xs:restriction base="xs:string">
      <xs:whiteSpace value="collapse" />
      <xs:enumeration value="start" />
      <xs:enumeration value="stop" />
      <xs:enumeration value="jump_to" />
      <xs:enumeration value="remove" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="easing">
    <xs:restriction base="xs:string">
      <xs:enumeration value="linear" />
      <xs:enumeration value="easeinquad" />
      <xs:enumeration value="easeoutquad" />
      <xs:enumeration value="easeinoutquad" />
      <xs:enumeration value="easeoutinquad" />
      <xs:enumeration value="easeincubic" />
      <xs:enumeration value="easeoutcubic" />
      <xs:enumeration value="easeinoutcubic" />
      <xs:enumeration value="easeoutincubic" />
      <xs:enumeration value="easeinquart" />
      <xs:enumeration value="easeoutquart" />
      <xs:enumeration value="easeinoutquart" />
      <xs:enumeration value="easeoutinquart" />
      <xs:enumeration value="easeinquint" />
      <xs:enumeration value="easeoutquint" />
      <xs:enumeration value="easeinoutquint" />
      <xs:enumeration value="easeoutinquint" />
      <xs:enumeration value="easeinsine" />
      <xs:enumeration value="easeoutsine" />
      <xs:enumeration value="easeinoutsine" />
      <xs:enumeration value="easeoutinsine" />
      <xs:enumeration value="easeinexpo" />
      <xs:enumeration value="easeoutexpo" />
      <xs:enumeration value="easeinoutexpo" />
      <xs:enumeration value="easeoutinexpo" />
      <xs:enumeration value="easeincirc" />
      <xs:enumeration value="easeoutcirc" />
      <xs:enumeration value="easeinoutcirc" />
      <xs:enumeration value="easeoutincirc" />
      <xs:enumeration value="easeinelastic" />
      <xs:enumeration value="easeoutelastic" />
      <xs:enumeration value="easeinoutelastic" />
      <xs:enumeration value="easeoutinelastic" />
      <xs:enumeration value="easeinback" />
      <xs:enumeration value="easeoutback" />
      <xs:enumeration value="easeinoutback" />
      <xs:enumeration value="easeoutintback" />
      <xs:enumeration value="easeoutbounce" />
      <xs:enumeration value="easeinbounce" />
      <xs:enumeration value="easeinoutbounce" />
      <xs:enumeration value="easeoutinbounce" />
    </xs:restriction>
  </xs:simpleType>
</xs:schema>
